// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Collections.Generic;
using CloudCoin_SafeScan;
using Foundation;
using UIKit;
using System.Linq;

namespace CloudCoinIOS
{
    public partial class FixFrackedViewController : BaseFormSheet
    {
        private List<CloudCoin> frackedList;

        public FixFrackedViewController(IntPtr handle) : base(handle)
        {
        }

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            InitializeProperties();

            IntializeMethods();
        }

        private void InitializeProperties()
        {
            frackedList = Safe.Instance.FrackedCoinsList.ToList();
            frackedTableView.Source = new FrackedTableSource(frackedList);

            frackedTableView.Layer.CornerRadius = 5f;
            frackedTableView.Layer.BorderColor = UIColor.LightGray.CGColor;
            frackedTableView.Layer.MasksToBounds = true;

            RAIDA.Instance.CoinFixStarted += CoinFixStarted;
            RAIDA.Instance.CoinFixProcessing += CoinFixProcessing;
            RAIDA.Instance.CoinFixFinished += CoinFixFinished;
        }

        private void CoinFixStarted(object sender, CoinFixStartedEventArgs e)
        {
            var coinBeingFixed = frackedList[e.coinindex];
            coinBeingFixed.StatusText = "Waiting node";// + e.NodeNumber + "...";
            var indexPath = NSIndexPath.FromRowSection((nint)e.coinindex, 0);
            InvokeOnMainThread(() =>
            {
                frackedTableView.ReloadRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.None);
            });
        }

        private void CoinFixProcessing(object sender, CoinFixProcessingEventArgs e)
        {
            var coinBeingFixed = frackedList[e.coinindex];
            coinBeingFixed.StatusText = "Fixing node" + e.NodeNumber; // + ", corner" + e.corner;
            var indexPath = NSIndexPath.FromRowSection((nint)e.coinindex, 0);
            InvokeOnMainThread(() =>
            {
                frackedTableView.ReloadRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.None);
            });
        }

        private void CoinFixFinished(object sender, CoinFixFinishedEventArgs e)
        {
            var coinBeingFixed = frackedList[e.coinindex];
            coinBeingFixed.StatusText = /*"Node " + e.NodeNumber + " was " + */(e.result == CloudCoin.raidaNodeResponse.pass ? "" : "not") + " fixed!";
            var indexPath = NSIndexPath.FromRowSection((nint)e.coinindex, 0);
            InvokeOnMainThread(() =>
            {
                frackedTableView.ReloadRows(new NSIndexPath[] { indexPath }, UITableViewRowAnimation.None);
            });
        }

        private void IntializeMethods()
        {
            btnClose.TouchUpInside += (sender, e) =>
            {
                RemoveAnimate();
            };
        }
    }

    public class FrackedTableSource : UITableViewSource
    {
        List<CloudCoin> frackedCoins;
        NSString CellIdentifier = new NSString("FrackedTableCell");

        public FrackedTableSource(List<CloudCoin> frackedCoins)
        {
            this.frackedCoins = frackedCoins;
        }

        public override nint RowsInSection(UITableView tableview, nint section)
        {
            return frackedCoins.Count;
        }

        public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
        {
            var cell = (FrackedTableCell)tableView.DequeueReusableCell(CellIdentifier);
            var coin = frackedCoins[indexPath.Row];

            //---- if there are no cells to reuse, create a new one
            if (cell == null)
            {
                cell = new FrackedTableCell(CellIdentifier);
            }
            cell.SetProgress(coin);

            return cell;
        }
    }
}
